{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Go copy me This site is useful for copying and pasting go syntax. Golang does not have a lot of built in libaries. It takes awhile to type out the entire syntax. This is useful for interviews","title":"Welcome to Go copy me"},{"location":"#welcome-to-go-copy-me","text":"This site is useful for copying and pasting go syntax. Golang does not have a lot of built in libaries. It takes awhile to type out the entire syntax. This is useful for interviews","title":"Welcome to Go copy me"},{"location":"BFS/","text":"BFS var queue []*TreeNode queue = append(queue, target) var depth int for len(queue) > 0 { size := len(queue) for i := 0; i < size; i++ { node := queue[0] queue = queue[1:] if depth == K { ans = append(ans, node.Val) continue } parent := data[node] if parent != nil && !visited[parent] { queue = append(queue, parent) } if node.Left != nil && !visited[node.Left] { queue = append(queue, node.Left) } if node.Right != nil && !visited[node.Right] { queue = append(queue, node.Right) } visited[node] = true } depth++ }","title":"BFS"},{"location":"BFS/#bfs","text":"var queue []*TreeNode queue = append(queue, target) var depth int for len(queue) > 0 { size := len(queue) for i := 0; i < size; i++ { node := queue[0] queue = queue[1:] if depth == K { ans = append(ans, node.Val) continue } parent := data[node] if parent != nil && !visited[parent] { queue = append(queue, parent) } if node.Left != nil && !visited[node.Left] { queue = append(queue, node.Left) } if node.Right != nil && !visited[node.Right] { queue = append(queue, node.Right) } visited[node] = true } depth++ }","title":"BFS"},{"location":"DFS/","text":"DFS var stack []Node stack = append(stack, Node{\"\", 0}) seen := make(map[Node]bool) for len(stack) > 0 { size := len(stack) top := stack[len(stack)-1] stack = stack[:len(stack)-1] if seen[top] { continue } seen[top] = true Printer(top) //do stuff for i := 0; i < size; i++ { for _, val := range graph[top] { if !seen[val] { stack = append(stack, val) } } } }","title":"DFS"},{"location":"DFS/#dfs","text":"var stack []Node stack = append(stack, Node{\"\", 0}) seen := make(map[Node]bool) for len(stack) > 0 { size := len(stack) top := stack[len(stack)-1] stack = stack[:len(stack)-1] if seen[top] { continue } seen[top] = true Printer(top) //do stuff for i := 0; i < size; i++ { for _, val := range graph[top] { if !seen[val] { stack = append(stack, val) } } } }","title":"DFS"},{"location":"DataStructure/","text":"Data Structure Array For array code comments arr := []int{1,2} arr := []string{\"\"} resArr := make([]int,len(arr)) Map For maps code comments MapName Key : Value 1 : 2 1 : 2 1 : 2 1 : 2 Map declaration hashMap := make(map[int]int) Stacks Illustrate /* stacks | | | | | | |_| Front - Last (LIFO) */ Stack-Int type Stack struct { stack []int } func (this *Stack) init() { this.stack = []int{} } func (this *Stack) Peek() int { return this.stack[len(this.stack)-1] } func (this *Stack) Pop() { if len(this.stack) > 0 { this.stack = this.stack[:len(this.stack)-1] } } func (this *Stack) Top() int { top := this.stack[len(this.stack)-1] this.stack = this.stack[:len(this.stack)-1] return top } func (this *Stack) Empty() bool { return len(this.stack) == 0 } func (this *Stack) Push(a int) { this.stack = append(this.stack, a) } func (this *Stack) Len() int { return len(this.stack) } Stack-String String stack type Stack struct { stack []string } func (this *Stack) init() { this.stack = []string{} } func (this *Stack) Peek() string { return this.stack[len(this.stack)-1] } func (this *Stack) Pop() { if len(this.stack) > 0 { this.stack = this.stack[:len(this.stack)-1] } } func (this *Stack) Top() string { top := this.stack[len(this.stack)-1] this.stack = this.stack[:len(this.stack)-1] return top } func (this *Stack) Empty() bool { return len(this.stack) == 0 } func (this *Stack) Push(a string) { this.stack = append(this.stack, a) } func (this *Stack) Len() int { return len(this.stack) }","title":"Data Structure"},{"location":"DataStructure/#data-structure","text":"","title":"Data Structure"},{"location":"DataStructure/#array","text":"For array code comments arr := []int{1,2} arr := []string{\"\"} resArr := make([]int,len(arr))","title":"Array"},{"location":"DataStructure/#map","text":"For maps code comments MapName Key : Value 1 : 2 1 : 2 1 : 2 1 : 2 Map declaration hashMap := make(map[int]int)","title":"Map"},{"location":"DataStructure/#stacks","text":"Illustrate /* stacks | | | | | | |_| Front - Last (LIFO) */","title":"Stacks"},{"location":"DataStructure/#stack-int","text":"type Stack struct { stack []int } func (this *Stack) init() { this.stack = []int{} } func (this *Stack) Peek() int { return this.stack[len(this.stack)-1] } func (this *Stack) Pop() { if len(this.stack) > 0 { this.stack = this.stack[:len(this.stack)-1] } } func (this *Stack) Top() int { top := this.stack[len(this.stack)-1] this.stack = this.stack[:len(this.stack)-1] return top } func (this *Stack) Empty() bool { return len(this.stack) == 0 } func (this *Stack) Push(a int) { this.stack = append(this.stack, a) } func (this *Stack) Len() int { return len(this.stack) }","title":"Stack-Int"},{"location":"DataStructure/#stack-string","text":"String stack type Stack struct { stack []string } func (this *Stack) init() { this.stack = []string{} } func (this *Stack) Peek() string { return this.stack[len(this.stack)-1] } func (this *Stack) Pop() { if len(this.stack) > 0 { this.stack = this.stack[:len(this.stack)-1] } } func (this *Stack) Top() string { top := this.stack[len(this.stack)-1] this.stack = this.stack[:len(this.stack)-1] return top } func (this *Stack) Empty() bool { return len(this.stack) == 0 } func (this *Stack) Push(a string) { this.stack = append(this.stack, a) } func (this *Stack) Len() int { return len(this.stack) }","title":"Stack-String"},{"location":"Loops/","text":"Loops For loops with i for i := 0; i < len(); i++ { }","title":"Loops"},{"location":"Loops/#loops","text":"","title":"Loops"},{"location":"Loops/#for-loops-with-i","text":"for i := 0; i < len(); i++ { }","title":"For loops with i"},{"location":"MinMax/","text":"Min Max Abs Min func Min(x, y int) int { if x < y { return x } return y } Max func Max(x, y int) int { if x > y { return x } return y } Abs func Abs(x int) int { if x <0 { return -x } return x }","title":"Min Max Abs"},{"location":"MinMax/#min-max-abs","text":"","title":"Min Max Abs"},{"location":"MinMax/#min","text":"func Min(x, y int) int { if x < y { return x } return y }","title":"Min"},{"location":"MinMax/#max","text":"func Max(x, y int) int { if x > y { return x } return y }","title":"Max"},{"location":"MinMax/#abs","text":"func Abs(x int) int { if x <0 { return -x } return x }","title":"Abs"},{"location":"Print/","text":"Print Println quick copy and paste - print for debuging fmt.Println()","title":"Print"},{"location":"Print/#print","text":"","title":"Print"},{"location":"Print/#println","text":"quick copy and paste - print for debuging fmt.Println()","title":"Println"},{"location":"Sort/","text":"Sort Slice Java has Array.sort(words). GO does not have a build in function. We have to do it from scratch. Slice words lexicographically sort.Slice(words, func(i, j int) bool { return len(words[i]) < len(words[j]) })","title":"Sort Slice"},{"location":"Sort/#sort-slice","text":"Java has Array.sort(words). GO does not have a build in function. We have to do it from scratch.","title":"Sort Slice"},{"location":"Sort/#slice-words-lexicographically","text":"sort.Slice(words, func(i, j int) bool { return len(words[i]) < len(words[j]) })","title":"Slice words lexicographically"},{"location":"Strings/","text":"Strings String Builder func join(strs ...string) string { var sb strings.Builder for _, str := range strs { sb.WriteString(str) } return sb.String() } var sb strings.Builder sb.WriteString(str) return sb.String() Contains Returns boolean strings.Contains(\"warren code\", \"code\") Fields String s is split on the basis of white spaces and store in a string array v = strings.Fields(\"warren code\") Repeats Repeats string 4 times res := strings.Repeat(str1, 4) ReplaceAll Returns new string with replaced word. Can be used to replace white character strings.ReplaceAll(\"original string to replace\", \"replace\", \"new\") Index Index returns the index of the first instance of substr in s, or -1 if substr is not present in s strings.Index(\"chicken\", \"ken\") Return 4. str := \"chicken\" idx := strings.Index(str, \"ken\") fmt.Print(str[:idx]) // prints chic Split Splits string by parameter passed in names := strings.Split(str, \":\") str := \"Warren:Veerasingam\" names := strings.Split(str, \":\") fmt.Print(names[0]) // prints Warren fmt.Print(names[1]) // prints Veerasingam","title":"Strings"},{"location":"Strings/#strings","text":"","title":"Strings"},{"location":"Strings/#string-builder","text":"func join(strs ...string) string { var sb strings.Builder for _, str := range strs { sb.WriteString(str) } return sb.String() } var sb strings.Builder sb.WriteString(str) return sb.String()","title":"String Builder"},{"location":"Strings/#contains","text":"Returns boolean strings.Contains(\"warren code\", \"code\")","title":"Contains"},{"location":"Strings/#fields","text":"String s is split on the basis of white spaces and store in a string array v = strings.Fields(\"warren code\")","title":"Fields"},{"location":"Strings/#repeats","text":"Repeats string 4 times res := strings.Repeat(str1, 4)","title":"Repeats"},{"location":"Strings/#replaceall","text":"Returns new string with replaced word. Can be used to replace white character strings.ReplaceAll(\"original string to replace\", \"replace\", \"new\")","title":"ReplaceAll"},{"location":"Strings/#index","text":"Index returns the index of the first instance of substr in s, or -1 if substr is not present in s strings.Index(\"chicken\", \"ken\") Return 4. str := \"chicken\" idx := strings.Index(str, \"ken\") fmt.Print(str[:idx]) // prints chic","title":"Index"},{"location":"Strings/#split","text":"Splits string by parameter passed in names := strings.Split(str, \":\") str := \"Warren:Veerasingam\" names := strings.Split(str, \":\") fmt.Print(names[0]) // prints Warren fmt.Print(names[1]) // prints Veerasingam","title":"Split"}]}